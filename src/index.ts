#!/usr/bin/env node
import { cleanupSingleProject } from './cleanupSingleProject.js';
import { CommanderError, program } from 'commander';
import { format as formatPath, parse as parsePath, resolve as resolvePath } from 'node:path';
import { EDITOR_BUNDLE_DEFAULT, EDITOR_BUNDLE_EXTRA_DEFAULT } from './constants.js';

interface CleanerOptions {
    editorBundle?: string,
    editorBundleExtra?: string,
    output?: string,
    replace?: boolean,
    legacyPreamble: boolean,
}

async function defaultAction(projectPath: string, options: CleanerOptions): Promise<void> {
    try {
        projectPath = resolvePath(projectPath);

        let editorBundle: string;
        if (options.editorBundle) {
            editorBundle = resolvePath(options.editorBundle);
        } else {
            editorBundle = resolvePath(parsePath(projectPath).dir, EDITOR_BUNDLE_DEFAULT);
        }


        let editorBundleExtra: string | null = null;
        if (options.editorBundleExtra) editorBundleExtra = resolvePath(options.editorBundleExtra);

        let outputPath: string;
        if (options.output) {
            outputPath = resolvePath(options.output);
        } else {
            const tempPath = parsePath(projectPath);
            tempPath.base = `cleaned-${tempPath.base}`;
            outputPath = formatPath(tempPath);
        }

        if (options.replace) {
            if (options.output) {
                throw new CommanderError(1, 'output-replace-clash', '--output option cannot be used with --replace flag');
            }

            outputPath = projectPath;
        }

        console.log(`Cleaning up project: "${projectPath}"...`);
        await cleanupSingleProject(projectPath, outputPath, editorBundle, editorBundleExtra, options.legacyPreamble);
    } catch(err) {
        if (err instanceof CommanderError) {
            program.error(err.message, { exitCode: err.exitCode, code: err.code });
        } else {
            console.error(err);
            program.error('Unexpected error occurred', { exitCode: 63, code: 'unexpected' });
        }
    }
}

program
    .argument('<project-path>', 'File path to project file that needs to be cleaned')
    .option('-o, --output <path>', 'Where the cleaned project file will be stored. Does not override the input project by default')
    .option('-r, --replace', 'Replace the input project. Cannot be used with --output')
    .option('-b, --editor-bundle <path>', `The editor bundle that was generated by the Wonderland Editor for the input project when building (default: "<project-path directory>/${EDITOR_BUNDLE_DEFAULT}")`)
    .option('-e, --editor-bundle-extra <path>', `Add extra definitions to the editor bundle via a JS script (default: "${EDITOR_BUNDLE_EXTRA_DEFAULT}")`)
    .option('--legacy-preamble', 'Includes the legacy type definitions in the editor bundle preamble (such as Howler and window types). Note that this will be disabled by default in the future, and eventually removed', true)
    .option('--no-legacy-preamble', 'Disables the legacy type definitions in the editor bundle preamble')
    .action(defaultAction)

program.parseAsync();